{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace, markdownSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Extension} */\n\nexport const gfmTable = {\n  flow: {\n    null: {\n      tokenize: tokenizeTable,\n      resolve: resolveTable\n    }\n  }\n};\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n};\n/** @type {Resolver} */\n\nfunction resolveTable(events, context) {\n  let index = -1;\n  /** @type {boolean|undefined} */\n\n  let inHead;\n  /** @type {boolean|undefined} */\n\n  let inDelimiterRow;\n  /** @type {boolean|undefined} */\n\n  let inRow;\n  /** @type {number|undefined} */\n\n  let contentStart;\n  /** @type {number|undefined} */\n\n  let contentEnd;\n  /** @type {number|undefined} */\n\n  let cellStart;\n  /** @type {boolean|undefined} */\n\n  let seenCellInRow;\n\n  while (++index < events.length) {\n    const token = events[index][1];\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index;\n        contentEnd = index;\n      }\n\n      if ( // Combine separate content parts into one.\n      (token.type === 'tableCellDivider' || token.type === 'tableRow') && contentEnd) {\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        };\n        /** @type {Token} */\n\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        };\n        assert(contentStart, 'expected `contentStart` to be defined if `contentEnd` is');\n        events.splice(contentStart, contentEnd - contentStart + 1, ['enter', content, context], ['enter', text, context], ['exit', text, context], ['exit', content, context]);\n        index -= contentEnd - contentStart - 3;\n        contentStart = undefined;\n        contentEnd = undefined;\n      }\n    }\n\n    if (events[index][0] === 'exit' && cellStart !== undefined && cellStart + (seenCellInRow ? 0 : 1) < index && (token.type === 'tableCellDivider' || token.type === 'tableRow' && (cellStart + 3 < index || events[cellStart][1].type !== types.whitespace))) {\n      const cell = {\n        type: inDelimiterRow ? 'tableDelimiter' : inHead ? 'tableHeader' : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      };\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, ['exit', cell, context]);\n      events.splice(cellStart, 0, ['enter', cell, context]);\n      index += 2;\n      cellStart = index + 1;\n      seenCellInRow = true;\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter';\n\n      if (inRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter';\n\n      if (inDelimiterRow) {\n        cellStart = index + 1;\n        seenCellInRow = false;\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter';\n    }\n  }\n\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<Align>} */\n\n  const align = [];\n  let tableHeaderCount = 0;\n  /** @type {boolean|undefined} */\n\n  let seenDelimiter;\n  /** @type {boolean|undefined} */\n\n  let hasDash;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align;\n    effects.enter('tableHead');\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    }\n\n    tableHeaderCount++;\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    seenDelimiter = true;\n    return cellBreakHead;\n  }\n  /** @type {State} */\n\n\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined;\n      tableHeaderCount++;\n    }\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceHead;\n    }\n\n    effects.exit(types.whitespace);\n    return cellBreakHead(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakHead(code);\n    }\n\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeHead : inCellContentHead;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentHead;\n    } // Anything else.\n\n\n    return inCellContentHead(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code);\n    }\n\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.exit('tableRow');\n    effects.exit('tableHead');\n    const originalInterrupt = self.interrupt;\n    self.interrupt = true;\n    return effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      effects.enter('tableDelimiterRow');\n      return atDelimiterRowBreak(code);\n    }, function (code) {\n      self.interrupt = originalInterrupt;\n      return nok(code);\n    })(code);\n  }\n  /** @type {State} */\n\n\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      align.push('none');\n      return inFillerDelimiter;\n    }\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align.push('left');\n      return afterLeftAlignment;\n    } // If we start with a pipe, we open a cell marker.\n\n\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    }\n\n    effects.exit(types.whitespace);\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code);\n      return inFillerDelimiter;\n    }\n\n    effects.exit('tableDelimiterFiller');\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment');\n      effects.consume(code);\n      effects.exit('tableDelimiterAlignment');\n      align[align.length - 1] = align[align.length - 1] === 'left' ? 'center' : 'right';\n      return afterRightAlignment;\n    }\n\n    return atDelimiterRowBreak(code);\n  }\n  /** @type {State} */\n\n\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller');\n      effects.consume(code);\n      hasDash = true;\n      return inFillerDelimiter;\n    } // Anything else is not ok.\n\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceDelimiter;\n    } // `|`\n\n\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider');\n      effects.consume(code);\n      effects.exit('tableCellDivider');\n      return atDelimiterRowBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow'); // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code);\n    }\n\n    if (code === codes.eof) {\n      return tableClose(code);\n    }\n\n    assert(markdownLineEnding(code), 'expected eol');\n    return effects.check(nextPrefixedOrBlank, tableClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize), tableClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableClose(code) {\n    effects.exit('table');\n    return ok(code);\n  }\n  /** @type {State} */\n\n\n  function bodyStart(code) {\n    effects.enter('tableBody');\n    return rowStartBody(code);\n  }\n  /** @type {State} */\n\n\n  function rowStartBody(code) {\n    effects.enter('tableRow'); // If we start with a pipe, we open a cell marker.\n\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    }\n\n    effects.enter('temporaryTableCellContent'); // Can’t be space or eols at the start of a construct, so we’re in a cell.\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`');\n    effects.enter('tableCellDivider');\n    effects.consume(code);\n    effects.exit('tableCellDivider');\n    return cellBreakBody;\n  }\n  /** @type {State} */\n\n\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code);\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace);\n      effects.consume(code);\n      return inWhitespaceBody;\n    } // `|`\n\n\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code);\n    } // Anything else is cell content.\n\n\n    effects.enter('temporaryTableCellContent');\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code);\n      return inWhitespaceBody;\n    }\n\n    effects.exit(types.whitespace);\n    return cellBreakBody(code);\n  }\n  /** @type {State} */\n\n\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (code === codes.eof || code === codes.verticalBar || markdownLineEndingOrSpace(code)) {\n      effects.exit('temporaryTableCellContent');\n      return cellBreakBody(code);\n    }\n\n    effects.consume(code);\n    return code === codes.backslash ? inCellContentEscapeBody : inCellContentBody;\n  }\n  /** @type {State} */\n\n\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code);\n      return inCellContentBody;\n    } // Anything else.\n\n\n    return inCellContentBody(code);\n  }\n  /** @type {State} */\n\n\n  function atRowEndBody(code) {\n    effects.exit('tableRow');\n\n    if (code === codes.eof) {\n      return tableBodyClose(code);\n    }\n\n    return effects.check(nextPrefixedOrBlank, tableBodyClose, effects.attempt({\n      tokenize: tokenizeRowEnd,\n      partial: true\n    }, factorySpace(effects, rowStartBody, types.linePrefix, constants.tabSize), tableBodyClose))(code);\n  }\n  /** @type {State} */\n\n\n  function tableBodyClose(code) {\n    effects.exit('tableBody');\n    return tableClose(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol');\n      effects.enter(types.lineEnding);\n      effects.consume(code);\n      effects.exit(types.lineEnding);\n      return factorySpace(effects, prefixed, types.linePrefix);\n    }\n    /** @type {State} */\n\n\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (self.parser.lazy[self.now().line] || code === codes.eof || markdownLineEnding(code)) {\n        return nok(code);\n      }\n\n      const tail = self.events[self.events.length - 1]; // Indented code can interrupt delimiter and body rows.\n\n      if (!self.parser.constructs.disable.null.includes('codeIndented') && tail && tail[1].type === types.linePrefix && tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize) {\n        return nok(code);\n      }\n\n      self._gfmTableDynamicInterruptHack = true;\n      return effects.check(self.parser.constructs.flow, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return nok(code);\n      }, function (code) {\n        self._gfmTableDynamicInterruptHack = false;\n        return ok(code);\n      })(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check'); // EOL.\n\n    effects.consume(code);\n    return whitespace;\n  }\n  /** @type {State} */\n\n\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code);\n      size++;\n      return size === constants.tabSize ? ok : whitespace;\n    } // EOF or whitespace\n\n\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code);\n    } // Anything else.\n\n\n    return nok(code);\n  }\n}","map":{"version":3,"sources":["/home/mash/Documents/Code/JavaScript/pl-md-resume/node_modules/micromark-extension-gfm-table/dev/lib/syntax.js"],"names":["ok","assert","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","markdownSpace","codes","constants","types","gfmTable","flow","null","tokenize","tokenizeTable","resolve","resolveTable","nextPrefixedOrBlank","tokenizeNextPrefixedOrBlank","partial","events","context","index","inHead","inDelimiterRow","inRow","contentStart","contentEnd","cellStart","seenCellInRow","length","token","type","content","start","end","text","chunkText","contentType","contentTypeText","splice","undefined","whitespace","cell","effects","nok","self","align","tableHeaderCount","seenDelimiter","hasDash","code","enter","_align","verticalBar","cellDividerHead","inCellContentHead","consume","exit","cellBreakHead","eof","atRowEndHead","inWhitespaceHead","backslash","inCellContentEscapeHead","originalInterrupt","interrupt","attempt","tokenizeRowEnd","atDelimiterRowBreak","rowEndDelimiter","inWhitespaceDelimiter","dash","push","inFillerDelimiter","colon","afterLeftAlignment","afterRightAlignment","tableClose","check","bodyStart","linePrefix","tabSize","rowStartBody","cellDividerBody","inCellContentBody","cellBreakBody","atRowEndBody","inWhitespaceBody","inCellContentEscapeBody","tableBodyClose","lineEnding","prefixed","parser","lazy","now","line","tail","constructs","disable","includes","sliceSerialize","_gfmTableDynamicInterruptHack","size","virtualSpace","space"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n */\n\n/**\n * @typedef {'left'|'center'|'right'|'none'} Align\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace,\n  markdownSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Extension} */\nexport const gfmTable = {\n  flow: {null: {tokenize: tokenizeTable, resolve: resolveTable}}\n}\n\nconst nextPrefixedOrBlank = {\n  tokenize: tokenizeNextPrefixedOrBlank,\n  partial: true\n}\n\n/** @type {Resolver} */\nfunction resolveTable(events, context) {\n  let index = -1\n  /** @type {boolean|undefined} */\n  let inHead\n  /** @type {boolean|undefined} */\n  let inDelimiterRow\n  /** @type {boolean|undefined} */\n  let inRow\n  /** @type {number|undefined} */\n  let contentStart\n  /** @type {number|undefined} */\n  let contentEnd\n  /** @type {number|undefined} */\n  let cellStart\n  /** @type {boolean|undefined} */\n  let seenCellInRow\n\n  while (++index < events.length) {\n    const token = events[index][1]\n\n    if (inRow) {\n      if (token.type === 'temporaryTableCellContent') {\n        contentStart = contentStart || index\n        contentEnd = index\n      }\n\n      if (\n        // Combine separate content parts into one.\n        (token.type === 'tableCellDivider' || token.type === 'tableRow') &&\n        contentEnd\n      ) {\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n        const content = {\n          type: 'tableContent',\n          start: events[contentStart][1].start,\n          end: events[contentEnd][1].end\n        }\n        /** @type {Token} */\n        const text = {\n          type: types.chunkText,\n          start: content.start,\n          end: content.end,\n          // @ts-expect-error It’s fine.\n          contentType: constants.contentTypeText\n        }\n\n        assert(\n          contentStart,\n          'expected `contentStart` to be defined if `contentEnd` is'\n        )\n\n        events.splice(\n          contentStart,\n          contentEnd - contentStart + 1,\n          ['enter', content, context],\n          ['enter', text, context],\n          ['exit', text, context],\n          ['exit', content, context]\n        )\n\n        index -= contentEnd - contentStart - 3\n        contentStart = undefined\n        contentEnd = undefined\n      }\n    }\n\n    if (\n      events[index][0] === 'exit' &&\n      cellStart !== undefined &&\n      cellStart + (seenCellInRow ? 0 : 1) < index &&\n      (token.type === 'tableCellDivider' ||\n        (token.type === 'tableRow' &&\n          (cellStart + 3 < index ||\n            events[cellStart][1].type !== types.whitespace)))\n    ) {\n      const cell = {\n        type: inDelimiterRow\n          ? 'tableDelimiter'\n          : inHead\n          ? 'tableHeader'\n          : 'tableData',\n        start: events[cellStart][1].start,\n        end: events[index][1].end\n      }\n      events.splice(index + (token.type === 'tableCellDivider' ? 1 : 0), 0, [\n        'exit',\n        cell,\n        context\n      ])\n      events.splice(cellStart, 0, ['enter', cell, context])\n      index += 2\n      cellStart = index + 1\n      seenCellInRow = true\n    }\n\n    if (token.type === 'tableRow') {\n      inRow = events[index][0] === 'enter'\n\n      if (inRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableDelimiterRow') {\n      inDelimiterRow = events[index][0] === 'enter'\n\n      if (inDelimiterRow) {\n        cellStart = index + 1\n        seenCellInRow = false\n      }\n    }\n\n    if (token.type === 'tableHead') {\n      inHead = events[index][0] === 'enter'\n    }\n  }\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTable(effects, ok, nok) {\n  const self = this\n  /** @type {Array<Align>} */\n  const align = []\n  let tableHeaderCount = 0\n  /** @type {boolean|undefined} */\n  let seenDelimiter\n  /** @type {boolean|undefined} */\n  let hasDash\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // @ts-expect-error Custom.\n    effects.enter('table')._align = align\n    effects.enter('tableHead')\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    tableHeaderCount++\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    assert(!markdownLineEndingOrSpace(code), 'expected non-space')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function cellDividerHead(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    seenDelimiter = true\n    return cellBreakHead\n  }\n\n  /** @type {State} */\n  function cellBreakHead(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndHead(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    if (seenDelimiter) {\n      seenDelimiter = undefined\n      tableHeaderCount++\n    }\n\n    if (code === codes.verticalBar) {\n      return cellDividerHead(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceHead(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceHead\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakHead(code)\n  }\n\n  /** @type {State} */\n  function inCellContentHead(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakHead(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeHead\n      : inCellContentHead\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeHead(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentHead\n    }\n\n    // Anything else.\n    return inCellContentHead(code)\n  }\n\n  /** @type {State} */\n  function atRowEndHead(code) {\n    if (code === codes.eof) {\n      return nok(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.exit('tableRow')\n    effects.exit('tableHead')\n    const originalInterrupt = self.interrupt\n    self.interrupt = true\n    return effects.attempt(\n      {tokenize: tokenizeRowEnd, partial: true},\n      function (code) {\n        self.interrupt = originalInterrupt\n        effects.enter('tableDelimiterRow')\n        return atDelimiterRowBreak(code)\n      },\n      function (code) {\n        self.interrupt = originalInterrupt\n        return nok(code)\n      }\n    )(code)\n  }\n\n  /** @type {State} */\n  function atDelimiterRowBreak(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      align.push('none')\n      return inFillerDelimiter\n    }\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n      align.push('left')\n      return afterLeftAlignment\n    }\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceDelimiter(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    effects.exit(types.whitespace)\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function inFillerDelimiter(code) {\n    if (code === codes.dash) {\n      effects.consume(code)\n      return inFillerDelimiter\n    }\n\n    effects.exit('tableDelimiterFiller')\n\n    if (code === codes.colon) {\n      effects.enter('tableDelimiterAlignment')\n      effects.consume(code)\n      effects.exit('tableDelimiterAlignment')\n\n      align[align.length - 1] =\n        align[align.length - 1] === 'left' ? 'center' : 'right'\n\n      return afterRightAlignment\n    }\n\n    return atDelimiterRowBreak(code)\n  }\n\n  /** @type {State} */\n  function afterLeftAlignment(code) {\n    if (code === codes.dash) {\n      effects.enter('tableDelimiterFiller')\n      effects.consume(code)\n      hasDash = true\n      return inFillerDelimiter\n    }\n\n    // Anything else is not ok.\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function afterRightAlignment(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return rowEndDelimiter(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceDelimiter\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      effects.enter('tableCellDivider')\n      effects.consume(code)\n      effects.exit('tableCellDivider')\n      return atDelimiterRowBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function rowEndDelimiter(code) {\n    effects.exit('tableDelimiterRow')\n\n    // Exit if there was no dash at all, or if the header cell count is not the\n    // delimiter cell count.\n    if (!hasDash || tableHeaderCount !== align.length) {\n      return nok(code)\n    }\n\n    if (code === codes.eof) {\n      return tableClose(code)\n    }\n\n    assert(markdownLineEnding(code), 'expected eol')\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(effects, bodyStart, types.linePrefix, constants.tabSize),\n        tableClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableClose(code) {\n    effects.exit('table')\n    return ok(code)\n  }\n\n  /** @type {State} */\n  function bodyStart(code) {\n    effects.enter('tableBody')\n    return rowStartBody(code)\n  }\n\n  /** @type {State} */\n  function rowStartBody(code) {\n    effects.enter('tableRow')\n\n    // If we start with a pipe, we open a cell marker.\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    effects.enter('temporaryTableCellContent')\n    // Can’t be space or eols at the start of a construct, so we’re in a cell.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function cellDividerBody(code) {\n    assert(code === codes.verticalBar, 'expected `|`')\n    effects.enter('tableCellDivider')\n    effects.consume(code)\n    effects.exit('tableCellDivider')\n    return cellBreakBody\n  }\n\n  /** @type {State} */\n  function cellBreakBody(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return atRowEndBody(code)\n    }\n\n    if (markdownSpace(code)) {\n      effects.enter(types.whitespace)\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    // `|`\n    if (code === codes.verticalBar) {\n      return cellDividerBody(code)\n    }\n\n    // Anything else is cell content.\n    effects.enter('temporaryTableCellContent')\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function inWhitespaceBody(code) {\n    if (markdownSpace(code)) {\n      effects.consume(code)\n      return inWhitespaceBody\n    }\n\n    effects.exit(types.whitespace)\n    return cellBreakBody(code)\n  }\n\n  /** @type {State} */\n  function inCellContentBody(code) {\n    // EOF, whitespace, pipe\n    if (\n      code === codes.eof ||\n      code === codes.verticalBar ||\n      markdownLineEndingOrSpace(code)\n    ) {\n      effects.exit('temporaryTableCellContent')\n      return cellBreakBody(code)\n    }\n\n    effects.consume(code)\n    return code === codes.backslash\n      ? inCellContentEscapeBody\n      : inCellContentBody\n  }\n\n  /** @type {State} */\n  function inCellContentEscapeBody(code) {\n    if (code === codes.backslash || code === codes.verticalBar) {\n      effects.consume(code)\n      return inCellContentBody\n    }\n\n    // Anything else.\n    return inCellContentBody(code)\n  }\n\n  /** @type {State} */\n  function atRowEndBody(code) {\n    effects.exit('tableRow')\n\n    if (code === codes.eof) {\n      return tableBodyClose(code)\n    }\n\n    return effects.check(\n      nextPrefixedOrBlank,\n      tableBodyClose,\n      effects.attempt(\n        {tokenize: tokenizeRowEnd, partial: true},\n        factorySpace(\n          effects,\n          rowStartBody,\n          types.linePrefix,\n          constants.tabSize\n        ),\n        tableBodyClose\n      )\n    )(code)\n  }\n\n  /** @type {State} */\n  function tableBodyClose(code) {\n    effects.exit('tableBody')\n    return tableClose(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeRowEnd(effects, ok, nok) {\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(markdownLineEnding(code), 'expected eol')\n      effects.enter(types.lineEnding)\n      effects.consume(code)\n      effects.exit(types.lineEnding)\n      return factorySpace(effects, prefixed, types.linePrefix)\n    }\n\n    /** @type {State} */\n    function prefixed(code) {\n      // Blank or interrupting line.\n      if (\n        self.parser.lazy[self.now().line] ||\n        code === codes.eof ||\n        markdownLineEnding(code)\n      ) {\n        return nok(code)\n      }\n\n      const tail = self.events[self.events.length - 1]\n\n      // Indented code can interrupt delimiter and body rows.\n      if (\n        !self.parser.constructs.disable.null.includes('codeIndented') &&\n        tail &&\n        tail[1].type === types.linePrefix &&\n        tail[2].sliceSerialize(tail[1], true).length >= constants.tabSize\n      ) {\n        return nok(code)\n      }\n\n      self._gfmTableDynamicInterruptHack = true\n\n      return effects.check(\n        self.parser.constructs.flow,\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return nok(code)\n        },\n        function (code) {\n          self._gfmTableDynamicInterruptHack = false\n          return ok(code)\n        }\n      )(code)\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNextPrefixedOrBlank(effects, ok, nok) {\n  let size = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    // This is a check, so we don’t care about tokens, but we open a bogus one\n    // so we’re valid.\n    effects.enter('check')\n    // EOL.\n    effects.consume(code)\n    return whitespace\n  }\n\n  /** @type {State} */\n  function whitespace(code) {\n    if (code === codes.virtualSpace || code === codes.space) {\n      effects.consume(code)\n      size++\n      return size === constants.tabSize ? ok : whitespace\n    }\n\n    // EOF or whitespace\n    if (code === codes.eof || markdownLineEndingOrSpace(code)) {\n      return ok(code)\n    }\n\n    // Anything else.\n    return nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}