{"ast":null,"code":"/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\nimport { patternCompile } from './pattern-compile.js';\nimport { patternInScope } from './pattern-in-scope.js';\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array<string>}} config\n * @returns {string}\n */\n\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '');\n  /** @type {Array<number>} */\n\n  const positions = [];\n  /** @type {Array<string>} */\n\n  const result = [];\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n\n  const infos = {};\n  let index = -1;\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index];\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue;\n    }\n\n    const expression = patternCompile(pattern);\n    /** @type {RegExpExecArray|null} */\n\n    let match;\n\n    while (match = expression.exec(value)) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak);\n      const after = ('after' in pattern);\n      const position = match.index + (before ? match[1].length : 0);\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false;\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false;\n        }\n      } else {\n        positions.push(position);\n        infos[position] = {\n          before,\n          after\n        };\n      }\n    }\n  }\n\n  positions.sort(numerical);\n  let start = config.before ? config.before.length : 0;\n  const end = value.length - (config.after ? config.after.length : 0);\n  index = -1;\n\n  while (++index < positions.length) {\n    const position = positions[index]; // Character before or after matched:\n\n    if (position < start || position >= end) {\n      continue;\n    } // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n\n\n    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after || positions[index - 1] === position - 1 && infos[position].before && !infos[position - 1].before && !infos[position - 1].after) {\n      continue;\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'));\n    }\n\n    start = position;\n\n    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {\n      // Character escape.\n      result.push('\\\\');\n    } else {\n      // Character reference.\n      result.push('&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';');\n      start++;\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after));\n  return result.join('');\n}\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\n\nfunction numerical(a, b) {\n  return a - b;\n}\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\n\n\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g;\n  /** @type {Array<number>} */\n\n  const positions = [];\n  /** @type {Array<string>} */\n\n  const results = [];\n  const whole = value + after;\n  let index = -1;\n  let start = 0;\n  /** @type {RegExpExecArray|null} */\n\n  let match;\n\n  while (match = expression.exec(whole)) {\n    positions.push(match.index);\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]));\n    }\n\n    results.push('\\\\');\n    start = positions[index];\n  }\n\n  results.push(value.slice(start));\n  return results.join('');\n}","map":{"version":3,"sources":["/home/mash/Documents/Code/JavaScript/pl-md-resume/node_modules/mdast-util-to-markdown/lib/util/safe.js"],"names":["patternCompile","patternInScope","safe","context","input","config","value","before","after","positions","result","infos","index","unsafe","length","pattern","stack","expression","match","exec","Boolean","atBreak","position","includes","push","sort","numerical","start","end","escapeBackslashes","slice","test","charAt","encode","charCodeAt","toString","toUpperCase","join","a","b","results","whole"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('../types.js').Context} Context\n * @typedef {import('../types.js').SafeOptions} SafeOptions\n */\n\nimport {patternCompile} from './pattern-compile.js'\nimport {patternInScope} from './pattern-in-scope.js'\n\n/**\n * @param {Context} context\n * @param {string|null|undefined} input\n * @param {SafeOptions & {encode?: Array<string>}} config\n * @returns {string}\n */\nexport function safe(context, input, config) {\n  const value = (config.before || '') + (input || '') + (config.after || '')\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const result = []\n  /** @type {Record<number, {before: boolean, after: boolean}>} */\n  const infos = {}\n  let index = -1\n\n  while (++index < context.unsafe.length) {\n    const pattern = context.unsafe[index]\n\n    if (!patternInScope(context.stack, pattern)) {\n      continue\n    }\n\n    const expression = patternCompile(pattern)\n    /** @type {RegExpExecArray|null} */\n    let match\n\n    while ((match = expression.exec(value))) {\n      const before = 'before' in pattern || Boolean(pattern.atBreak)\n      const after = 'after' in pattern\n      const position = match.index + (before ? match[1].length : 0)\n\n      if (positions.includes(position)) {\n        if (infos[position].before && !before) {\n          infos[position].before = false\n        }\n\n        if (infos[position].after && !after) {\n          infos[position].after = false\n        }\n      } else {\n        positions.push(position)\n        infos[position] = {before, after}\n      }\n    }\n  }\n\n  positions.sort(numerical)\n\n  let start = config.before ? config.before.length : 0\n  const end = value.length - (config.after ? config.after.length : 0)\n  index = -1\n\n  while (++index < positions.length) {\n    const position = positions[index]\n\n    // Character before or after matched:\n    if (position < start || position >= end) {\n      continue\n    }\n\n    // If this character is supposed to be escaped because it has a condition on\n    // the next character, and the next character is definitly being escaped,\n    // then skip this escape.\n    if (\n      (position + 1 < end &&\n        positions[index + 1] === position + 1 &&\n        infos[position].after &&\n        !infos[position + 1].before &&\n        !infos[position + 1].after) ||\n      (positions[index - 1] === position - 1 &&\n        infos[position].before &&\n        !infos[position - 1].before &&\n        !infos[position - 1].after)\n    ) {\n      continue\n    }\n\n    if (start !== position) {\n      // If we have to use a character reference, an ampersand would be more\n      // correct, but as backslashes only care about punctuation, either will\n      // do the trick\n      result.push(escapeBackslashes(value.slice(start, position), '\\\\'))\n    }\n\n    start = position\n\n    if (\n      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&\n      (!config.encode || !config.encode.includes(value.charAt(position)))\n    ) {\n      // Character escape.\n      result.push('\\\\')\n    } else {\n      // Character reference.\n      result.push(\n        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'\n      )\n      start++\n    }\n  }\n\n  result.push(escapeBackslashes(value.slice(start, end), config.after))\n\n  return result.join('')\n}\n\n/**\n * @param {number} a\n * @param {number} b\n * @returns {number}\n */\nfunction numerical(a, b) {\n  return a - b\n}\n\n/**\n * @param {string} value\n * @param {string} after\n * @returns {string}\n */\nfunction escapeBackslashes(value, after) {\n  const expression = /\\\\(?=[!-/:-@[-`{-~])/g\n  /** @type {Array<number>} */\n  const positions = []\n  /** @type {Array<string>} */\n  const results = []\n  const whole = value + after\n  let index = -1\n  let start = 0\n  /** @type {RegExpExecArray|null} */\n  let match\n\n  while ((match = expression.exec(whole))) {\n    positions.push(match.index)\n  }\n\n  while (++index < positions.length) {\n    if (start !== positions[index]) {\n      results.push(value.slice(start, positions[index]))\n    }\n\n    results.push('\\\\')\n    start = positions[index]\n  }\n\n  results.push(value.slice(start))\n\n  return results.join('')\n}\n"]},"metadata":{},"sourceType":"module"}