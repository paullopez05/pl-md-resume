{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\nimport { ok as assert } from 'uvu/assert';\nimport { blankLine } from 'micromark-core-commonmark';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { types } from 'micromark-util-symbol/types.js';\nconst indent = {\n  tokenize: tokenizeIndent,\n  partial: true\n};\n/**\n * @returns {Extension}\n */\n\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {\n          tokenize: tokenizeDefinitionContinuation\n        },\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeGfmFootnoteCall\n      },\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  };\n}\n/** @type {Tokenizer} */\n\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  let index = self.events.length;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {Token} */\n\n  let labelStart; // Find an opening.\n\n  while (index--) {\n    const token = self.events[index][1];\n\n    if (token.type === types.labelImage) {\n      labelStart = token;\n      break;\n    } // Exit if we’ve walked far enough.\n\n\n    if (token.type === 'gfmFootnoteCall' || token.type === types.labelLink || token.type === types.label || token.type === types.image || token.type === types.link) {\n      break;\n    }\n  }\n\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`');\n\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code);\n    }\n\n    const id = normalizeIdentifier(self.sliceSerialize({\n      start: labelStart.end,\n      end: self.now()\n    }));\n\n    if (id.charCodeAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code);\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return ok(code);\n  }\n}\n/** @type {Resolver} */\n\n\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length;\n  /** @type {Token|undefined} */\n\n  let labelStart; // Find an opening.\n\n  while (index--) {\n    if (events[index][1].type === types.labelImage && events[index][0] === 'enter') {\n      labelStart = events[index][1];\n      break;\n    }\n  }\n\n  assert(labelStart, 'expected `labelStart` to resolve'); // Change the `labelImageMarker` to a `data`.\n\n  events[index + 1][1].type = types.data;\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'; // The whole (without `!`):\n\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }; // The `^` marker\n\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }; // Increment the end 1 character.\n\n  marker.end.column++;\n  marker.end.offset++;\n  marker.end._bufferIndex++;\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  };\n  const chunk = {\n    type: types.chunkString,\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  };\n  /** @type {Array<Event>} */\n\n  const replacement = [// Take the `labelImageMarker` (now `data`, the `!`)\n  events[index + 1], events[index + 2], ['enter', call, context], // The `[`\n  events[index + 3], events[index + 4], // The `^`.\n  ['enter', marker, context], ['exit', marker, context], // Everything in between.\n  ['enter', string, context], ['enter', chunk, context], ['exit', chunk, context], ['exit', string, context], // The ending (`]`, properly parsed and labelled).\n  events[events.length - 2], events[events.length - 1], ['exit', call, context]];\n  events.splice(index, events.length - index + 1, ...replacement);\n  return events;\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  let size = 0;\n  /** @type {boolean} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter('gfmFootnoteCall');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    return callStart;\n  }\n  /** @type {State} */\n\n\n  function callStart(code) {\n    if (code !== codes.caret) return nok(code);\n    effects.enter('gfmFootnoteCallMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallMarker');\n    effects.enter('gfmFootnoteCallString');\n    effects.enter('chunkString').contentType = 'string';\n    return callData;\n  }\n  /** @type {State} */\n\n\n  function callData(code) {\n    /** @type {Token} */\n    let token;\n\n    if (code === codes.eof || code === codes.leftSquareBracket || size++ > constants.linkReferenceSizeMax) {\n      return nok(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      if (!data) {\n        return nok(code);\n      }\n\n      effects.exit('chunkString');\n      token = effects.exit('gfmFootnoteCallString');\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token))) ? end(code) : nok(code);\n    }\n\n    effects.consume(code);\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    return code === codes.backslash ? callEscape : callData;\n  }\n  /** @type {State} */\n\n\n  function callEscape(code) {\n    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {\n      effects.consume(code);\n      size++;\n      return callData;\n    }\n\n    return callData(code);\n  }\n  /** @type {State} */\n\n\n  function end(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`');\n    effects.enter('gfmFootnoteCallLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteCallLabelMarker');\n    effects.exit('gfmFootnoteCall');\n    return ok;\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this;\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);\n  /** @type {string} */\n\n  let identifier;\n  let size = 0;\n  /** @type {boolean|undefined} */\n\n  let data;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter('gfmFootnoteDefinition')._container = true;\n    effects.enter('gfmFootnoteDefinitionLabel');\n    effects.enter('gfmFootnoteDefinitionLabelMarker');\n    effects.consume(code);\n    effects.exit('gfmFootnoteDefinitionLabelMarker');\n    return labelStart;\n  }\n  /** @type {State} */\n\n\n  function labelStart(code) {\n    if (code === codes.caret) {\n      effects.enter('gfmFootnoteDefinitionMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionMarker');\n      effects.enter('gfmFootnoteDefinitionLabelString');\n      return atBreak;\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function atBreak(code) {\n    /** @type {Token} */\n    let token;\n\n    if (code === codes.eof || code === codes.leftSquareBracket || size > constants.linkReferenceSizeMax) {\n      return nok(code);\n    }\n\n    if (code === codes.rightSquareBracket) {\n      if (!data) {\n        return nok(code);\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString');\n      identifier = normalizeIdentifier(self.sliceSerialize(token));\n      effects.enter('gfmFootnoteDefinitionLabelMarker');\n      effects.consume(code);\n      effects.exit('gfmFootnoteDefinitionLabelMarker');\n      effects.exit('gfmFootnoteDefinitionLabel');\n      return labelAfter;\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding');\n      effects.consume(code);\n      effects.exit('lineEnding');\n      size++;\n      return atBreak;\n    }\n\n    effects.enter('chunkString').contentType = 'string';\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function label(code) {\n    if (code === codes.eof || markdownLineEnding(code) || code === codes.leftSquareBracket || code === codes.rightSquareBracket || size > constants.linkReferenceSizeMax) {\n      effects.exit('chunkString');\n      return atBreak(code);\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true;\n    }\n\n    size++;\n    effects.consume(code);\n    return code === codes.backslash ? labelEscape : label;\n  }\n  /** @type {State} */\n\n\n  function labelEscape(code) {\n    if (code === codes.leftSquareBracket || code === codes.backslash || code === codes.rightSquareBracket) {\n      effects.consume(code);\n      size++;\n      return label;\n    }\n\n    return label(code);\n  }\n  /** @type {State} */\n\n\n  function labelAfter(code) {\n    if (code === codes.colon) {\n      effects.enter('definitionMarker');\n      effects.consume(code);\n      effects.exit('definitionMarker'); // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace');\n    }\n\n    return nok(code);\n  }\n  /** @type {State} */\n\n\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier);\n    }\n\n    return ok(code);\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok));\n}\n/** @type {Exiter} */\n\n\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition');\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this;\n  return factorySpace(effects, afterPrefix, 'gfmFootnoteDefinitionIndent', constants.tabSize + 1);\n  /** @type {State} */\n\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1];\n    return tail && tail[1].type === 'gfmFootnoteDefinitionIndent' && tail[2].sliceSerialize(tail[1], true).length === constants.tabSize ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"sources":["/home/mash/Documents/Code/JavaScript/pl-md-resume/node_modules/micromark-extension-gfm-footnote/dev/lib/syntax.js"],"names":["ok","assert","blankLine","factorySpace","markdownLineEnding","markdownLineEndingOrSpace","codes","constants","normalizeIdentifier","types","indent","tokenize","tokenizeIndent","partial","gfmFootnote","document","leftSquareBracket","tokenizeDefinitionStart","continuation","tokenizeDefinitionContinuation","exit","gfmFootnoteDefinitionEnd","text","tokenizeGfmFootnoteCall","rightSquareBracket","add","tokenizePotentialGfmFootnoteCall","resolveTo","resolveToPotentialGfmFootnoteCall","effects","nok","self","index","events","length","defined","parser","gfmFootnotes","labelStart","token","type","labelImage","labelLink","label","image","link","start","code","_balanced","id","sliceSerialize","end","now","charCodeAt","caret","includes","slice","enter","consume","context","data","call","Object","assign","marker","column","offset","_bufferIndex","string","chunk","chunkString","contentType","replacement","splice","size","callStart","callData","eof","linkReferenceSizeMax","backslash","callEscape","identifier","_container","atBreak","labelAfter","labelEscape","colon","done","push","check","attempt","afterPrefix","tabSize","tail"],"mappings":"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","sourcesContent":["/**\n * @typedef {import('micromark-util-types').Extension} Extension\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Token} Token\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Exiter} Exiter\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Event} Event\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {blankLine} from 'micromark-core-commonmark'\nimport {factorySpace} from 'micromark-factory-space'\nimport {\n  markdownLineEnding,\n  markdownLineEndingOrSpace\n} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\nimport {types} from 'micromark-util-symbol/types.js'\n\nconst indent = {tokenize: tokenizeIndent, partial: true}\n\n/**\n * @returns {Extension}\n */\nexport function gfmFootnote() {\n  /** @type {Extension} */\n  return {\n    document: {\n      [codes.leftSquareBracket]: {\n        tokenize: tokenizeDefinitionStart,\n        continuation: {tokenize: tokenizeDefinitionContinuation},\n        exit: gfmFootnoteDefinitionEnd\n      }\n    },\n    text: {\n      [codes.leftSquareBracket]: {tokenize: tokenizeGfmFootnoteCall},\n      [codes.rightSquareBracket]: {\n        add: 'after',\n        tokenize: tokenizePotentialGfmFootnoteCall,\n        resolveTo: resolveToPotentialGfmFootnoteCall\n      }\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizePotentialGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  let index = self.events.length\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {Token} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    const token = self.events[index][1]\n\n    if (token.type === types.labelImage) {\n      labelStart = token\n      break\n    }\n\n    // Exit if we’ve walked far enough.\n    if (\n      token.type === 'gfmFootnoteCall' ||\n      token.type === types.labelLink ||\n      token.type === types.label ||\n      token.type === types.image ||\n      token.type === types.link\n    ) {\n      break\n    }\n  }\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n\n    if (!labelStart || !labelStart._balanced) {\n      return nok(code)\n    }\n\n    const id = normalizeIdentifier(\n      self.sliceSerialize({start: labelStart.end, end: self.now()})\n    )\n\n    if (id.charCodeAt(0) !== codes.caret || !defined.includes(id.slice(1))) {\n      return nok(code)\n    }\n\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return ok(code)\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveToPotentialGfmFootnoteCall(events, context) {\n  let index = events.length\n  /** @type {Token|undefined} */\n  let labelStart\n\n  // Find an opening.\n  while (index--) {\n    if (\n      events[index][1].type === types.labelImage &&\n      events[index][0] === 'enter'\n    ) {\n      labelStart = events[index][1]\n      break\n    }\n  }\n\n  assert(labelStart, 'expected `labelStart` to resolve')\n\n  // Change the `labelImageMarker` to a `data`.\n  events[index + 1][1].type = types.data\n  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker'\n\n  // The whole (without `!`):\n  const call = {\n    type: 'gfmFootnoteCall',\n    start: Object.assign({}, events[index + 3][1].start),\n    end: Object.assign({}, events[events.length - 1][1].end)\n  }\n  // The `^` marker\n  const marker = {\n    type: 'gfmFootnoteCallMarker',\n    start: Object.assign({}, events[index + 3][1].end),\n    end: Object.assign({}, events[index + 3][1].end)\n  }\n  // Increment the end 1 character.\n  marker.end.column++\n  marker.end.offset++\n  marker.end._bufferIndex++\n  const string = {\n    type: 'gfmFootnoteCallString',\n    start: Object.assign({}, marker.end),\n    end: Object.assign({}, events[events.length - 1][1].start)\n  }\n  const chunk = {\n    type: types.chunkString,\n    contentType: 'string',\n    start: Object.assign({}, string.start),\n    end: Object.assign({}, string.end)\n  }\n\n  /** @type {Array<Event>} */\n  const replacement = [\n    // Take the `labelImageMarker` (now `data`, the `!`)\n    events[index + 1],\n    events[index + 2],\n    ['enter', call, context],\n    // The `[`\n    events[index + 3],\n    events[index + 4],\n    // The `^`.\n    ['enter', marker, context],\n    ['exit', marker, context],\n    // Everything in between.\n    ['enter', string, context],\n    ['enter', chunk, context],\n    ['exit', chunk, context],\n    ['exit', string, context],\n    // The ending (`]`, properly parsed and labelled).\n    events[events.length - 2],\n    events[events.length - 1],\n    ['exit', call, context]\n  ]\n\n  events.splice(index, events.length - index + 1, ...replacement)\n\n  return events\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeGfmFootnoteCall(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  let size = 0\n  /** @type {boolean} */\n  let data\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteCall')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    return callStart\n  }\n\n  /** @type {State} */\n  function callStart(code) {\n    if (code !== codes.caret) return nok(code)\n\n    effects.enter('gfmFootnoteCallMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallMarker')\n    effects.enter('gfmFootnoteCallString')\n    effects.enter('chunkString').contentType = 'string'\n    return callData\n  }\n\n  /** @type {State} */\n  function callData(code) {\n    /** @type {Token} */\n    let token\n\n    if (\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      size++ > constants.linkReferenceSizeMax\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      if (!data) {\n        return nok(code)\n      }\n\n      effects.exit('chunkString')\n      token = effects.exit('gfmFootnoteCallString')\n      return defined.includes(normalizeIdentifier(self.sliceSerialize(token)))\n        ? end(code)\n        : nok(code)\n    }\n\n    effects.consume(code)\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    return code === codes.backslash ? callEscape : callData\n  }\n\n  /** @type {State} */\n  function callEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return callData\n    }\n\n    return callData(code)\n  }\n\n  /** @type {State} */\n  function end(code) {\n    assert(code === codes.rightSquareBracket, 'expected `]`')\n    effects.enter('gfmFootnoteCallLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteCallLabelMarker')\n    effects.exit('gfmFootnoteCall')\n    return ok\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinitionStart(effects, ok, nok) {\n  const self = this\n  /** @type {Array<string>} */\n  // @ts-expect-error It’s fine!\n  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = [])\n  /** @type {string} */\n  let identifier\n  let size = 0\n  /** @type {boolean|undefined} */\n  let data\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`')\n    effects.enter('gfmFootnoteDefinition')._container = true\n    effects.enter('gfmFootnoteDefinitionLabel')\n    effects.enter('gfmFootnoteDefinitionLabelMarker')\n    effects.consume(code)\n    effects.exit('gfmFootnoteDefinitionLabelMarker')\n    return labelStart\n  }\n\n  /** @type {State} */\n  function labelStart(code) {\n    if (code === codes.caret) {\n      effects.enter('gfmFootnoteDefinitionMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionMarker')\n      effects.enter('gfmFootnoteDefinitionLabelString')\n      return atBreak\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function atBreak(code) {\n    /** @type {Token} */\n    let token\n\n    if (\n      code === codes.eof ||\n      code === codes.leftSquareBracket ||\n      size > constants.linkReferenceSizeMax\n    ) {\n      return nok(code)\n    }\n\n    if (code === codes.rightSquareBracket) {\n      if (!data) {\n        return nok(code)\n      }\n\n      token = effects.exit('gfmFootnoteDefinitionLabelString')\n      identifier = normalizeIdentifier(self.sliceSerialize(token))\n      effects.enter('gfmFootnoteDefinitionLabelMarker')\n      effects.consume(code)\n      effects.exit('gfmFootnoteDefinitionLabelMarker')\n      effects.exit('gfmFootnoteDefinitionLabel')\n      return labelAfter\n    }\n\n    if (markdownLineEnding(code)) {\n      effects.enter('lineEnding')\n      effects.consume(code)\n      effects.exit('lineEnding')\n      size++\n      return atBreak\n    }\n\n    effects.enter('chunkString').contentType = 'string'\n    return label(code)\n  }\n\n  /** @type {State} */\n  function label(code) {\n    if (\n      code === codes.eof ||\n      markdownLineEnding(code) ||\n      code === codes.leftSquareBracket ||\n      code === codes.rightSquareBracket ||\n      size > constants.linkReferenceSizeMax\n    ) {\n      effects.exit('chunkString')\n      return atBreak(code)\n    }\n\n    if (!markdownLineEndingOrSpace(code)) {\n      data = true\n    }\n\n    size++\n    effects.consume(code)\n    return code === codes.backslash ? labelEscape : label\n  }\n\n  /** @type {State} */\n  function labelEscape(code) {\n    if (\n      code === codes.leftSquareBracket ||\n      code === codes.backslash ||\n      code === codes.rightSquareBracket\n    ) {\n      effects.consume(code)\n      size++\n      return label\n    }\n\n    return label(code)\n  }\n\n  /** @type {State} */\n  function labelAfter(code) {\n    if (code === codes.colon) {\n      effects.enter('definitionMarker')\n      effects.consume(code)\n      effects.exit('definitionMarker')\n      // Any whitespace after the marker is eaten, forming indented code\n      // is not possible.\n      // No space is also fine, just like a block quote marker.\n      return factorySpace(effects, done, 'gfmFootnoteDefinitionWhitespace')\n    }\n\n    return nok(code)\n  }\n\n  /** @type {State} */\n  function done(code) {\n    if (!defined.includes(identifier)) {\n      defined.push(identifier)\n    }\n\n    return ok(code)\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinitionContinuation(effects, ok, nok) {\n  // Either a blank line, which is okay, or an indented thing.\n  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))\n}\n\n/** @type {Exiter} */\nfunction gfmFootnoteDefinitionEnd(effects) {\n  effects.exit('gfmFootnoteDefinition')\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeIndent(effects, ok, nok) {\n  const self = this\n\n  return factorySpace(\n    effects,\n    afterPrefix,\n    'gfmFootnoteDefinitionIndent',\n    constants.tabSize + 1\n  )\n\n  /** @type {State} */\n  function afterPrefix(code) {\n    const tail = self.events[self.events.length - 1]\n    return tail &&\n      tail[1].type === 'gfmFootnoteDefinitionIndent' &&\n      tail[2].sliceSerialize(tail[1], true).length === constants.tabSize\n      ? ok(code)\n      : nok(code)\n  }\n}\n"]},"metadata":{},"sourceType":"module"}